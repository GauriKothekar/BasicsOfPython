# -*- coding: utf-8 -*-
"""basicsOfPython.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KQiBCkr69IV0l3bqEE5A46i3gymmQfgS
"""

print("gauri kothekar")



str1="gauri"
x=20
print( x * str1) #static loop





"""# `**5** **june** **2023**`"""



num1=100
num1=200
print(num1)

str="abcdef"
print(str[-1])
print(str[1])
print(str[:])
print(str[::])
print(str[:-1])
print(str[::-1])
print(str[2:-1])
print(str[-1:])

del str[1]
print(str)

str1=str.upper()
print(str1)

print(str.lower())

list1 = ['a','b','c','d','e']
print(list1)

list1.append('gauri')
print(list1)

list1.extend("ab")
print(list1)

list1.insert(2 ,'kothekar')
print(list1)

list1.pop()
print(list1)

list1.pop(5)
print(list1)

list1.remove("kothekar")
print(list1)

list1.clear()
print(list1)

del list1

print(list1)

"""# **6 june 2023**"""

#tuple creation
tup=(1,2,3)
print(tup[1])
# print(tup.index(1))

tup1=(2,4,5)
tup2=(4,7,8)
print(tup1+tup2) #concatenation

#methods index and count

print(tup1[1])


tup3=(2,3,3,3,3,4)
print(tup3.count(3))
print(tup3.index(3))

#tuple inside list
li=[(2,4),5]
print(li[0][1])

#list inside tuple
tupp=([1,2,3,4],7)
print(tupp[0])
print(tupp.count(7))

tup4 = ()
tup5=(50)
print(tup4+tup5)

tup4 = ()
tup5=(50,)
print(tup4+tup5)

dic1={1:2,3:5 ,"x":"y"}
print(dic1[3])      # no indexing , it is done by key

#add method
dic1={1:2,3:5 ,"x":"y"}
print(dic1.update({"gauri":"kothekar"}))

dic1={1:2,3:5 ,"x":"y"}
dic1.update({"gauri":"kothekar"}) #add ke liye update
print(dic1)

# update
dic1[3]="gauri"
print(dic1)

# remove

dic1.pop(1) #pop with key
print(dic1)

dic1.popitem()
print(dic1)

#clear and del

print(dic1.keys()) #stored in the form of list

print(dic1.values())   #stored in the form of list

set1={1,2,3,4,5}
print(set)

#methods

#add and remove
set1.add(6)
print(set1)

set1.remove(4)
print(set1)

set1={1,2,3,4,5}
set2={6,7,8,9,0}
print(set1.union(set2))

set1={1,2,3,4,5}
set2={6,7,8,9,0}
print(set1.intersection(set2))

set1={1,2,3,4,5}
set2={6,7,8,9,0}
print(set1.difference(set2))

set1={1,2,3,4,5}
set2={6,7,8,9,0}
print(set1.symmetric_difference(set2))

print(set1 | set2)
print(set1 & set2)
print(set1 - set2)
print(set1 ^ set2)

#control statements

#if....
x=5
if x==5:
  print("the number matches")

x,y=5,6
if x<y:
  print("x is lesser")
else:
  print("x is greater")

x,y,z=5,6,7
if x<y:
  print("x is smallest")
elif x>y:
  print(" x is larger")
else:
  print(" y is largest")

x=20
if x%3==0:
  if x%5==0:
    print("it is divisible by both")
  else:
    print("5 se nahi")
else:
  print(" nhi")

x=[1,2,3,4,5]
for i in x:
  print(i)

for i in range(0,15):
  print(i*i)

x=10
i=0
while(i<x):
  print("hello itm")
  i=i+1

x=10
i=0
while(i<x):
  print("hello itm")
  i=i+1
  break



i=0
n=10
while i<n:
  i=i+1
  if i==6:
    continue
  print(i)

#for....else

li=[1,2,3,4]
for i in li:
  if i==2:
    print(i)
else:
  print("hy")

#for ....while
li1=[1,2,3,4]
while li1:
  print(li1)


else:
  print("bye")

#list comprehension

list1=[x for x in range (0 , 10)]
print(list1)

list2=[x  * x for x in range(0,10)]
print(list2)

# dictionary comprehension

list3={x: x*x for x in range(0,20)}
print(list3)

# zip function

li1=[1,2,3,4,5]
li2=[2,3,4,5,6]
for i in zip(li1,li2):
  print(i)

li1=[1,2,3,4,5]
li2=[2,3,4,5,6]

for i_li1 , i_li2 in zip(li1,li2):
  print(i_li1,i_li2)

"""**`7 june 2023`**


"""

def foo(x):
  print(x)

foo(5)

def foo(x,y):
  print( x+y)


foo(4,5)

#creating tuple and multiple values can be stored

def foo(*num):
  print(num)



foo(10,20,40,50)

def foo(**num):
  print(num)


foo(hy ="gauri")

def foo():
  print("gauri")

print(foo())

def big(a,b):
  res=a+b
  return res

  def small():
    rsqr=res**2
    return rsqr
  return small

print(big(10,20))

def big(a,b):
  res=a+b

  def small():
    rsqr=res**2
    return rsqr
  return small

print(big(10,20))

def big(a,b):
  res=a+b

  def small():
    rsqr=res**2
    return rsqr
  return small()

print(big(10,20))

def big(a,b):
  res=a+b
  yield res

  def small():
    rsqr=res**2
    return rsqr
  return small()

print(big(10,20))





# decorator
# allows you to modify the functionality of function.it wraps inside .
#In Python, a decorator is a design pattern that allows you to modify the functionality of a function by wrapping it in another function.

# The outer function is called the decorator, which takes the original function as an argument and returns a modified version of it.

def outer(x):
  def inner(y):
    return y+y
  return inner

valu1=outer(5)
value=valu1(6)
print(value)

# decorator
# allows you to modify the functionality of function.it wraps inside .
#In Python, a decorator is a design pattern that allows you to modify the functionality of a function by wrapping it in another function.

# The outer function is called the decorator, which takes the original function as an argument and returns a modified version of it.

def outer(x):
  def inner():
    return x+x
  return inner

valu1=outer(5)
value=valu1()
print(value)

def hello():
    def hi():
        print("Hello")
    return hi
new = hello()
new()

#iterator

mytuple = [1,2,3,4,5]
my = iter(mytuple)
# print(my)
# print(next(my))
for i in my:
  print(i)

def table(num):
  w=iter(num)
  return w


table("hi")

def table(num):
  w=iter(num)

  for i in w:
    print(i)

table("gauri")

def table(num):
  # w=iter(num)

  for i in iter(range(num)):
    print(i)

table(20)



def myname(func):
  print("gauri")
  def mysurname():
    print("kothekar")
  return mysurname


@myname

def daily_backup():
  print('Daily backup job has finished.')


daily_backup()

def myname(func):
  print("gauri")
  func()
  def mysurname():
    print("kothekar")
    func()
  return mysurname


@myname

def daily_backup():
  print('Daily backup job has finished.')


daily_backup()

def gen_func(x,y):
  z=x+y
  return z

gen_func(2,5)

# #The yield keyword in Python is similar to a return statement used for returning values in Python which returns a generator object to the one who calls the function which contains yield, instead of simply returning a value. The main difference between them is, the return statement terminates the execution of the function. Whereas, the yield statement only pauses the execution of the function. Another difference is return statements are never executed. whereas, yield statements are executed when the function resumes its execution.

# Advantages of yield:

# Using yield keyword is highly memory efficient, since the execution happens only when the caller iterates over the object.
# As the variables states are saved, we can pause and resume from the same point, thus saving time.
# Disadvantages of yield:

# Sometimes it becomes hard to understand the flow of code due to multiple times of value return from the function generator.
# Calling of generator functions must be handled properly, else might cause errors in program



def gen_func(x,y):
  yield x+y  #uses iterator


# gen_func(2,4)

for i in gen_func(4,7):
  print(i)

print(next(gen_func(2,4)))

def gen_func(x,y):
  yield x+y  #uses iterator
  return x+y


# gen_func(2,4)

for i in gen_func(4,7):
  print(i)

print(next(gen_func(2,4)))

o=gen_func(4,5)
y=o()
print(y)

def add(x,y):
  yield x+y  #uses iterator yield makes int interator

def sub(x,y):
  return x-y

print(next(add(5,2)))
# print(next(sub(5,2)))
sub(5,2)

def gauri(x,y):
  yield x+y

k=gauri(5,4)
print(next(k))

def even(func):
  print("number is even")
  func()
  def odd():
    print("number is odd")
    func()
  return odd

@even
def natural():
  print("it is also natural")



natural()

def girl():
  print("she is pretty")
  def boy(func):
    print("he is handsome")
    func()
  return boy

@boy
def gender():
  print("it includes both")

gender()

def girl(func):
  print("she is pretty")
  func()
  def boy():
    print("he is handsome")
    func()
  return boy

@girl

def gender():
  print("also smarter")


gender()

def start_roll(func):
  def end_roll():
    for i in range(2000,2006):
       func()
       print("betn1cs",i)
  return end_roll


@start_roll

def common():
  print("itm university")

common()

dic={2:2,4:5}

x=iter(dic)
print((next(x)))
print((next(x)))

li=[1,2,3,4,5]
x=iter(li)
# print(next(x))
for i in x:
  print(i)

string="gauri"
x=iter(string)
for i in x:
  print(i)

tup=(1,2,3)
x=iter(tup)
for i in x:
  print(i)

"""8 june 2023"""

#class

class DemoClass:
  var = 10


value = DemoClass()
print(value.var)

class Student:
  def roll(self):
    print("these are engineers")


object = Student()
object.roll()

class Btech:
  def cse(self):
    print("computer science")

  def civil(self):
    print("these are like architect")


object =Btech()
object.cse()
object.civil()

class University:
  def government(self):
    print("top ")

  def autonomous(self):
    print("average")


object1=University()
object1.government()

class MyClass:
  num=10


ob1=MyClass()
print(ob1.num)

class MyClass:
  num=10


print(MyClass.num)

class MyClass:
  num=10

MyClass.num=3000
print(MyClass.num)

class MyClass:
  def show(self):
    print("hy")


x=MyClass()
x.show()

class MyClass:
  def show(self):
    print("hy")


MyClass.show(x)

class MyClass:
  def show(self):
    print("hy")

x=MyClass()
MyClass.show(x)

class  MyClass:
  def show(self):
    self.name="gauri"


print(MyClass.show(x))

class MyClass:
  def show(self):
    print("hello")
    self.name="gauri"


MyClass.show(x)

class MyClass:
  def show(self):
    print("hello")
    self.name="how are you"

n1=MyClass()
n1.show()
print(n1.name)

class Student:
  def info(self):
    self.name="gauri"
    self.rollnumber="20016"


ob=Student()
ob.info()
print(ob.name)
# print(Student.info(x))
# ob=Student()
# ob.info()

class Student:
  def info(self):
    self.name="gauri"
    self.rollnumber="20016"



print(Student.info(x))
ob=Student()
ob.info()
print(ob.name)
print(ob.rollnumber)

class Home:
  room = 3
  kitchen= 1
  hall = 2



h1=Home()
h2=Home()

print(h1.room)
print(h1.kitchen)
print(h1.hall)


print(h1.room)
print(h1.kitchen)
print(h1.hall)

class Home:
  room = 3
  kitchen= 1
  hall = 2



h1=Home()
h2=Home()

h1.room = 5
print(h1.room)

print(h2.room)

class Home:
  room = 3
  kitchen= 1
  hall = 2


print(Home.room)

class Home:
  room = 3
  kitchen = 1
  hall = 2

  def show(self):
    print("hy")


# print(Home.room)

Home.show(x)

class Home:
  room = 3
  kitchen = 1
  hall = 2

  def show(self):
    print("hello")

print(Home.room)
Home.show(x)   #when print it will return none

class MyClass:
  num = 100



ob1=MyClass()
ob2=MyClass()

print(MyClass.num)
print(ob1.num)
print(ob2.num)


MyClass.num =2000
print(ob1.num)
print(MyClass.num)

class MyClass:
  num=100


ob1=MyClass()
ob1.area=10   #manipulation
print(ob1.area)

word="gauri"
print(*word)

x=6
y=2
print(x/y)
x=6
y=2
print(x//y)

#python inheritance

#single inheritance


class Parent():
  def parentA(self):
    return("Parent A")

class Child(Parent):
  def childA(self):
    print("Child a")


obj=Child()
obj.childA()
obj.parentA()

# print(Parent.parentA(obj))

class Parent:
  def parentA(self):
    print("Parent A")

class Child(Parent):
  def childA(self):
    print("Child a")


obj=Child()
obj.childA()
obj.parentA()

class TeacherCS:
  def cse(self):
    print("these are cse faculty")

class TeacherCivil(TeacherCS):
  def civil(self):
    print(" this is civil faculty")


class TeacherBoth(TeacherCivil):
  def both(self):
    print("can teach both")



ob=TeacherBoth()
ob.both()
ob.civil()
ob.cse()

class TeacherCS:
  def cse(self):
    print("these are cse faculty")

class TeacherCivil():
  def civil(self):
    print(" this is civil faculty")


class TeacherBoth(TeacherCivil,TeacherCS):
  def both(self):
    print("can teach both")



ob=TeacherBoth()
ob.both()
ob.civil()
ob.cse()

class A:
    def __init__(self):
        self.a = 1
        self.b = 2
        self.c = 3
    def seta(self):
        def afunction():
            self.a = 4
        afunction()
    def geta(self):
        return self.a


ob=A()
print(A.seta.afunction())

#laptop program

class Camera:
  def __init__(self,sensor,megapixel):




class Keyboard:
  def __init__(self,keys,lights):


class Screen:
  def __init__(self,size,resolution,type):




class Laptop:
  def __init__(self,name):

  def __init__(name,Camera,Keyboard,):

class Student:

    def __init__(self, id):
        self._id = id

    def registration_number(self, department_id) -> str:
        return str(self._id) + '-' + department_id


class Department:

    def __init__(self, id, student):
        self._id = id
        self._student = student

    def student_registration(self):
        return self._student.registration_number(self._id)


if __name__ == '__main__':
    student = Student(10)
    department = Department('ENG', student)
    print(department.student_registration())



"""**june 9 2023**"""

class MyClass:
  num=10
  def show(self):
    self.name="gauri"


print(MyClass.num)
obj1=MyClass()
print(obj1.show())
print(obj1.name)

class MyClass:
  def __init__(self,num , name):
    self.name=name
    self.num=num


obj1=MyClass(5,"gauri")
obj1.name
# obj1.num

class MyClass:
  def __init__(self,num , name):
    self.name=name
    self.num=num


obj1=MyClass(5,"gauri")
print(obj1.name)

#constructor vs method

class MyClass:
  def __init__(self):
    print("gauri")


o1=MyClass()
o1.__init__()

class MyClass:
  def __init__(self):
    return "gauri"


o1= MyClass()
o1.__init__()

class MyClass:
  def __init__(self):
    print("hy how are you")
    # return None

o1=MyClass()

class MyClass:
  def __init__(self):
    print("hy how are you")
    # return None

o1=MyClass()

class MyClass:
  def __init__(self,num):
    self.num=num

  def __repr__(self):
    return str(self.num)


m1 = MyClass(10)
print(m1)
print(m1.__str__())

class MyClass:
  pass


obj1=MyClass()
print(type(MyClass))

class MyClass:
  def __init__(self , num , name):
    num2=num
    name2=name
    print(num2)
    print(name2)

obj1 = MyClass(7,"gk")
# print(obj1.num2)

class MyClass:
  def __init__(self , num , name):
    self.num=num
    self.name=name


ob=MyClass(4,"hk")
print(ob.num)
print(ob.name)

class Camera:
  def __init__(self,sensor,mp):
    self.sensor=sensor
    self.mp=mp

class Keyboard:
  def __init__(self,keys,light):
    self.keys=keys
    self.light=light

class Screen:
  def __init__(self,size,resolution,stype):
    self.size =size
    self.resolution = resolution
    self.stype=stype




class Laptop:
  logo_name ="lenovo"
  def __init__(self,name,camera,keyboard,screen):
    self.name=name
    self.camera=camera
    self.keyboard=keyboard
    self.screen=screen


  def __str__(self):
    return f"Model:{self.name},\n \t Camera :(sensor:{self.camera.sensor} , mp:{self.camera.mp}),\n\t Keyboard:(keys:{self.keyboard.keys},light:{self.keyboard.light}),\n\t Screen:(size:{self.screen.size},Res:{self.screen.resolution},Type: {self.screen.stype})"


camera1 =Camera("Soby","48")
keyboard1=Keyboard("mechanical","rgbb")
screen1=Screen("26inch","600x400","led")


laptop1 = Laptop("ROG",camera1,keyboard1,screen1)
print(laptop1)

class MyClass:
  def display(self):
    self.name="gauri"
    self.age=20


ob=MyClass()
ob.display()
ob.name
ob.age

class MyClass:
  def __init__(self, num , age):
    self.num=num
    self.age=age

obj1=MyClass(3,4)
print(obj1.num)
print(obj1.age)

class MyClass:
  def __init__(self,name,age):
    self.name=name
    self.age=age


ob=MyClass("gauri",20)
print(ob.name)
print(ob.age)

class MyClass:
  def __init__(self,age):
    self.age = age
    if age >=18:
      # self.age=18
      print("valid")
    else:
      self.age=0
      print("not")


ob=MyClass(int(input()))
(ob.age)

"""**10 june 2023**"""

#encapsulation


class MyClass:
  __name="gauri"

  def __private_method(self):
    print("private")


obj=MyClass()

class MyClass:
  def __init__(self,name,age):
    self.__name =name
    self.__age=age

  def pvt(self):
    print(self.__name , self.__age)


obj=MyClass("ITM",22)
# obj.__init__("itm ", 22)
# print(obj.__name)
obj.pvt()

class MyClass:
  def __init__(self , name , age):
    self.__name=name
    self.age=age

  def pvt(self):
    return self.__name , self.age

obj=MyClass("itm ",  23)
obj.pvt()
name,age=obj.pvt()
print(name)
print(age)

class MyClass:
  def __init__(self , name = None , age = 0):
    self.__name = name
    self.__age=age

  def set_name(self,name):
    self.__name=name

  def get_name(self):
    return self.__name


  def set_age(self , age):
    self.__age=age

  def get_age(self):
    return self.__age

obj=MyClass()
obj.set_name("ITM")
print(obj.get_name())
obj.set_age(22)
print(obj.get_age())

#abstraction
from abc import ABC , abstractmethod

class Bike(ABC):
  @abstractmethod
  def show(self):
    pass

  def defined_method(self):
    print("hello")

  name="itm"

# b1=Bike()
# b1.show()

class Child(Bike):
  def show(self):
    print("implemented")

  color="blacck"

ch=Child()
ch.show()
ch.defined_method()
print(ch.name)
print(ch.color)

#practice

class ITM:
  def __init__(self,course,fees):
    self.course=course
    self.__fees=fees


i=ITM("btech",1000)
print(i.course)
print(i.__fees)

class ITM:
  def __init__(self , course=None , fees=0 ):
    self.__course=course
    self.__fees= fees

  def set_course(self,course):
    self.__course=course

  def get_course(self):
    return self.__course

  def set_fees(self,fees):
    self.__fees=fees

  def get_fees(self):
    return self.__fees


ob=ITM()
ob.set_course()
print(ob.get_course())
#
ob.set_fees()
print(ob.get_fees())

class ITM:
  def __init__(self , course=None , fees=0 ):
    self.__course=course
    self.__fees= fees

  def set_course(self,course):
    self.__course=course

  def get_course(self):
    return self.__course

  def set_fees(self,fees):
    self.__fees=fees

  def get_fees(self):
    return self.__fees


ob=ITM()
ob.set_course("btech")
print(ob.get_course())
ob.set_fees(2000000)
print(ob.get_fees())

#astract
from abc import ABC , abstractmethod

class Animal:
  def sleep(self):
    print("going to sleep")

  @abstractmethod
  def sound(self):
    print("defines sound")
    pass

class Snake:
  def sound(self):
    print("i hissss")



ob=Animal()
ob.sleep()
ob.sound()
ob=Snake()
ob.sound()

class Student:
  def __init__(self,name=None,idd= 0):
    self.__name=name
    self.__idd=idd


  def set_name(self,name):
    self.__name=name

  def get_name(self):
    return self.__name

  def set_idd(self,idd):
    self.__idd=idd

  def get_idd(self):
    return self.__idd


ob=Student()
ob.set_name("gauri")
print(ob.get_name())
ob.set_idd(22)
print(ob.get_idd())

from abc import ABC , abstractmethod
class ITM:
  def student(self):
    print("I am an ITMIAN")

  @abstractmethod
  def btech(self):
    print("i am btech student")


class Cse:
  def btech(self):
    print("i am cse student")

class Civil:
  def btech(self):
    print("i am i")


ob=ITM()
ob.student()
ob.btech()
ob=Cse()
ob.btech(

)

"""**12 june 2023**"""

#inheritance single

class Parent:
  def parent(self):
    print("parent class")

class Child(Parent):
  def child(self):
    print("cchild ")


ch = Child()
# ch.parent()
ch.child()
ch.parent()

class Gparent1:
  def gparent1(self):
    print("grandmom") #hybrid

class Gparent2:
  def gparent2(self):
    print("grandpapa")


class Son(Gparent1 , Gparent2):
  def son(self):
    print("mere papa")


class Grandson(Son):
  def grandson(self):
    print("i am child")



ch=Grandson()
ch.grandson()
ch.son()
ch.gparent1()
ch.gparent2()

#multilevel
class GGparent:
  def ggparent(self):
    print("greatgrandfather") #hybrid

class Gparent(GGparent):
  def gparent(self):
    print("grandpapa")


class Son(Gparent):
  def son(self):
    print("mere papa")


class Grandson(Son):
  def grandson(self):
    print("i am child")



ch=Grandson()
ch.grandson()
ch.son()
ch.ggparent()
ch.gparent()

#hybrid

class parent:
  def parent(self):
    print("papa")


class Son1(parent):
  def son(self):
    print("bada beta")

class Son2(parent):
  def son2(parent):
    print("chota beta")


ch=Son2()
ch.son2()

ch1=Son1()
ch1.son()

ch.parent()

#multiple

class parent1:
  def parent1(self):
    print("mom")


class parent2:
  def parent2(self):
    print("papa")


class Son1(parent1,parent2):
  def son(self):
    print("bada beta")

class Son2(parent2,parent1):
  def son2(self):
    print("chota beta")



ch=Son2()
ch.son2()
ch.parent1()
ch.parent2()

ch=Son1()
ch.son()
ch.parent1()
ch.parent2()

class Parent:
  def __init__(self):
    print("this is parent")


class Child(Parent):
  def __init__(self):
    super().__init__()
    print("child method")


ch=Child()

class Parent:
  def __init__(self):
    print("parent")

class Child(Parent):
  def __init__(self):
    super().__init__()
    print("child")
    super().__init__()


ch=Child()

class Parent:
  def __init__(self , surname):
    self.surname=surname
    print("parent method")

class Child(Parent):
  def __init__(self):
    super().__init__("kothekar")
    print("child")

ch=Child()
print(ch.surname)

class Parent:
  def __init__(self):
    self.surname="kothekar"

  def show(self , age):
    print("this is parent method")

class Child(Parent):
  def child(self):
    print("this is child")
    super().show(22)
    print(self.surname)

ch=Child()
ch.child()

#multiple inheritance
class Parent1:
  def method(self):
    print("method 1")

class Parent2:
  def method(self):
    print("method 2")

class Child(Parent1,Parent2):
  print("child")


ch=Child()
ch.method()

#multiple inheritance
class Parent1:
  def method(self):
    print("method 1")

class Parent2:
  def method(self):
    print("method 2")

class Child(Parent2,Parent1):
  print("child")


ch=Child()
ch.method()

class Parent1:
  def __init__(self):
    print("1")

class Parent2:
  def __init__(self):
    print("2")

class Child(Parent1,Parent2):
  def __init__(self):
    super().__init__()
    print("child")

ch=Child()

class Parent1:
  def __init__(self):
    print("1")


class Parent2:
  def __init__(self):
    print("2")

class Child(Parent1,Parent2):
  def __init__(self):
    Parent1().__init__()
    print("child")

ch=Child()

#polymorphism

#--1--method overriding
#--2--method overloading
#---3--operator

class Parent:
  def method(self):
    print("parent")



class Child(Parent):
  def method1(self):
    print("child")


ch=Child()
ch.method()

class Parent:
  def method(self):
    print("parent")



class Child(Parent):
  def method(self , num1):
    print("child")


ch=Child()
ch.method()
ch.method(10)

#method overloading change parammeters but reside within the class

class MyClass:
  def method(self,num1 ):
    print("this is method one")

  def method(self , num1 , num2):
    print("this is mothod two")

m=MyClass()
m.method(100)
m.method(100,200)

#operator overloading


class MyClass:
  def __init__(self , num):
    self.num=num

  def __add__(self ,other):
    return self.num+other.num

  def __mul__(self , other):
    return self.num * other.num

  def __sub__(self , other):
    return self.num - other.num

  def __div__(self , other):
    return self.num / other.num

  def __lt__(self , other):
    return self.num < other.num

  def __pow__(self , other):
    return self.num ** other.num

  def __floordiv__(self , other):
    return self.num // other.num

m1=MyClass(10)
m2=MyClass(20)
# print(m1.num+m2.num)
# print(m1.num*m2.num)
# print(m1.num-m2.num)
# print(m1.num/m2.num)
print(m1+m2)
print(m1*m2)
print(m1<m2)
print(m1**m2)
print(m1//m2)

class MyClass:
  def __init__(self , num , num2):
    self.num=num
    self.num2=num2

  def __add__(self ,other,other1):
    return self.num+self.num

  def __mul__(self , other , other1):
    return self.num * self.num

  def __sub__(self , other , other1):
    return self.num - self.num

  def __div__(self , other , other1):
    return self.num / self.num

  def __lt__(sel)


m1=MyClass(100)
m2=MyClass(200)
m3=MyClass(100)
# print(m1.nu)
# print(m1.num*m2.num*m3.num)
# print(m1.num-m2.num-m3.num)
# print(m1.num/m2.num/m3.num)
print(m1+m2+m3)

#duck type
class Alien:
  def fly(self):
    print("this is an alien")

class Human:
  def overthinker(self):
    print("this is human")

class Animal:
  def eat(self):
    print("this is an animal")


dog = Animal()
jadu = Alien()
manav =  Human()


def checkk(sel):
  sel.eat()
  sel.fly()
  sel.overthinker()


checkk(dog)
# checkk(jadu)
# checkk(manav)

"""**13 june 2023**"""

# #exception handling
# try----yha error ati he
# except ----- yha us error ko solve krte he
# finally----ye data resource ko end karne k lie use krt he

# exception is also a part of error but we do not handle the errors but we handle the exceptions

# there can be multi try multi catch.
# only single finally


#it can be try except and else  and try else:

print("start")
try:
  print(10/2)
except Exception as e:
  print(e)

print("start")
try:
  print(10/0)
except ArithmeticError as e:
  print(e)

print("gauri kothekar")

try:
  x=int(input())
  print(100/x)


except Exception as e:
  print("there is some errror")


finally:
  print("ennd")

print("hy")

try:
  li=[1,2,3,4]
  print(li[7])

except Exception as e:
  print(e)

print("start")

try:
  tup=(8,5,6,7,8,9)
  print(tup[10])


except ArithmeticError as e:
  print(e)

print("start")

try:
  tup=(8,5,6,7,8,9)
  print(tup[10])


except IndexError as e:
  print(e)

#multi except

try:
  print(10/0)

except Exception as e:
  print(e)

except ArithmeticError as e:
  print(e)

#multi except  #ese nhi likhna hota he kuki exception sare exception which are actually not to be .

try:
  print(10/0)

except Exception as e:
  print(e)

except ArithmeticError as e:
  print(e)

#multi except

try:
  print(10/0)

except ArithmeticError as e:
  print(e)

except Exception as e:
  print(e)

except ArithmeticError as e:
  print(e)

#multi try

try:
  print(10/2) #jab isme error he to vo direct iske exception me jyga but jb ism error nhi to vo uske andr jyga
  try:
    print(10/5)
  except ArithmeticError as e:
    print(e)

except ArithmeticError as e:
  print(e)

#multi try

try:
  print(10/2) #jab isme error he to vo direct iske exception me jyga but jb ism error nhi to vo uske andr jyga
  try:
    print(10/0)
  except ArithmeticError as e:
    print(e)

except ArithmeticError as e:
  print(e)

#multi try

try:
  print(10/0) #jab isme error he to vo direct iske exception me jyga but jb ism error nhi to vo uske andr jyga
  try:
    print(10/0)
  except ArithmeticError as e:
    print(e)

except ArithmeticError as e:
  print(e)

#multi try

try:
  print(10/0) #jab isme error he to vo direct iske exception me jyga but jb ism error nhi to vo uske andr jyga
  try:
    print(10/2)
  except ArithmeticError as e:
    print(e)

except ArithmeticError as e:
  print(e)

try:
  try:
    print(10/0)
    li=[1,2,3,4]
    print(li[5])

  except Exception as e:
    print(e)
    # li=[1,2,3,4]
    # print(li[5])

except Exception as e:
  print(e)

try:
  try:
    print(10/0)

  except Exception as e:
    print(e)
    li=[1,2,3,4]
    print(li[5])

except Exception as e:
  print(e)

#finally block  isme pehle finally call hoga fir error ayga

try:
  print(10/0)

finally:
  print("ho gaya")

print("end")

try:
  print(10/0)

except ZeroDivisionError as e:
  print(e)

#custom exception

#use raise keyword to throw the custom or user defined exception

x=int(input("enter the marks"))
try:
  if x>10:
    print("you are pass")
  else:
    raise ArithmeticError("You are fail")
finally:
  print("good luck")

class InvalidAgeException(Exception):
  pass

try:
  x=int(input("enter your age"))
  if x<18:
    raise InvalidAgeException
  else:
    print("you are eligible")

except InvalidAgeException:
  print("invalid age")



class Error(BaseException):
  def __init__(self , msg):
    print(msg)

marks = int(input("enter marks"))
if marks<50:
  raise Error("fail")

else:
  print("fail")

class Error(BaseException):
  def __init__(self,msg):
    self.msg=msg
    print(self.msg)

marks = int(input("enter marks"))
if marks<50:
  raise Error("fail")

else:
  print("fail")

class Error(BaseException):
  def __init__(self,msg):
    self.msg=msg
    super().__init__(msg)

marks = int(input("enter marks"))
if marks<50:
  raise Error("fail")

else:
  print("pass")

class InvalidSalary(BaseException):
  def __init__(self , salary , msg="salary is not in range of(5000 , 15000)"):
    self.salary=salary
    self.msg = msg
    super().__init__(self.msg)


salary = int(input("enter"))
if not 5000<salary < 15000:
  raise InvalidSalary(salary)

class StudentFailError(BaseException):
  def __init__(self,marks, result="fail"):
    self.marks=marks
    self.result=result
    super().__init__(self.result)


m=int(input("enter the marks"))
if m<33:
  raise StudentFailError(marks)

else:
  print("you are pass !!!!")

class OuterClass:
  num=10

  class InnerClass:
    def __init__(self):
      self.OuterClass.num
      print("this is inner")

ob=OuterClass()
# ob.num
# ob1=InnerClass()
# ob1.inner()

class Outer(object):
  num=120


  class Inner(object):
    @staticmethod
    def get_num(cls):
      return Outer.num

  Inner.num2=num

class Outer(object):
    def __init__(self):
        self.a = 111

print(f"Outer.a = {Outer().a}")

class Outer(object):
    a = 1

    class Inner(object):
        a = 2

        @classmethod
        def fun(cls):
          return Outer.a

print(Outer.Inner.fun())

class Car(object):
  car=10
  print("this is the sedan car")

  class Engine(object):
    print("Engine is mandatory")

    @classmethod
    def engine(cls):
      return Car.car

print(Car.Engine.engine())

class Outer:
  var=15
  class Inner:
    def access(self):
      return Outer.var

print(Outer.Inner.access(15))

"""**14 june 2023**"""

#file handling
f=open("PythonFh.txt","r")
f.close()

#file handling
f=open("PythonFh.txt","w")
f.write("my name is gaurik ") #it overwrites the data
f.close()

#file handling
f=open("PythonFh.txt","a")
f.write("i am in final year")  #adds the data
f.close()

#file handling
f=open("Python.txt","a")
f.write("i am an engineer")
f.close()

#file handling
f=open("Python.txt","a")
f.write("i am an engineer")
f.close()

#file handling
f=open("Python.txt","r")
# f.write("i am an engineer")
print(f.read(10))
f.close()

#file handling
f=open("Python.txt","r")
print(f.readline(5))
f.close()

#file handling
f=open("PythonFh.txt","r")
print(f.readlines(5))
f.close()

#file handling
f=open("Python.txt","r")
for x in f:
  print(x)
f.close()

#dump---->write
#load----> read

li=[1,2,3,4,5]
f1=open("Python.txt", "wb")
print(f1)
print(type(f1))
print(id(f1))
import pickle
pickle.dump(li,f1)          #serialization ---> object is converted to byte
f1.close()
f1=open("Python.txt","rb")   #deserialization ---> vice versa
pickle.load(f1)
print(f1)
print(type(f1))
print(id(f1))
f1.close()

with open("PythonFh.txt","r") as f1 , open("Python.txt","w") as f2:  #data is copied but with overwritten
  f2.write(f1.read())
  print(id("Python.txt"))
  print(id("PythonFh.txt"))
  f1.seek(2)
  print(f1.tell())
  print(f1.readline())

try:
  print("open file")
  f1 = open("PythonFh.txt","r")
  print(10/0)
  print("read file")
  print(f1.read())

except Exception as e:
  print(e)   ??

finally:
  f1.close()
  print("close file")

class Student:
  def __init__(self,name,age):
    self.name=name
    self.age=age


  def __str__(self):
    return self.name +str(self.age)


s1=Student("gauri",20)
s2=Student("gk",21)
s3=Student("gkkki",22)


f1=open("PythonFh.txt","wb")
import pickle
pickle.dump(s1,f1)
pickle.dump(s2,f1)
pickle.dump(s3,f1)
f1.close()

f1=open("PythonFh.txt","rb")
print(pickle.load(f1))
print(pickle.load(f1))
print(pickle.load(f1))

class Methods:
  name="pawan"

  def instance_method(self):
    print("this is instance method")

  def static_method()

#revers a string
def reverse(str):
  str1=""
  for i in str:
    str1=i+str1
  return str1


# str="gauri"
# print(str)
# print(reverse(str))
print(reverse("gauri"))

str1="gauri"
str2=str1.reverse()
print(str2)

#convrt list to string

lis=["gauri","kothkar","22"]
string = "".join(lis)
print(string)
print(type(string))

l1=[1,2,3,4,5]
l2=[2,3,4,5,6]
# a=set(l1)
# b=set(l2)
# if a==b:
#   print("yes")
# else:
#   print("NO")

# x=l1.sort()
# y=l2.sort()
# print(x)
# print(y)
x=sorted(l1)
print(x)
y=sorted(l2)
print(y)

#int to string
x=50
print(type(x))
print(x)
y=str(x)
print(type(y))
print(y)

n = 25
# check  and print type of num variable
print(type(n))
print(n)

# convert the num into string
con_num = str(n)

# check  and print type converted_num variable
print(type(con_num))
print(con_num)

"""**15 june 2023**"""

#multithreading
from threading import Thread
class MyThread(Thread):
  def run(self):
    for i in range(0,50):
      print(i)

th=MyThread()
th.start()

from threading import Thread

class MyClass(Thread):
  def run(self):
    for i in range (0 ,40):
       print("gauri")

if __name__== "__main__":

  th1=MyClass()
  th1.start()

  th2=MyClass()
  th2.start()

from threading import Thread
class MyClass1(Thread):
  def run(self):
    for i in range(0,29):
      print("gauri")


class MyClass2(Thread):
  def run(self):
    for i in range(0,9):
      print("kothekar")



th1=MyClass1()
th1.start()
th2=MyClass2()
th2.start()

#without class
from threading import Thread

def show():
  for i in range(0 , 10):
    print(i)

def show2():
  for i in range(0,19):
    print(i)

if __name__ == "__main__":

  t1=Thread(target = show)
  t1.start()
  t2=Thread(target=show2)
  t2.start()

from time import sleep
# from threading import Thread

def show():
  for count in range(0,15):
    # print("gauri")
    try:
      sleep(1)
      print("gauri")
    except Exception as e:
      print(e)

if __name__ == "__main__":
  th1=Thread(target=show)
  th1.start()

import threading
import time
def say_Hi():
  for i in range(3):
    time.sleep(1)
    print("hy")

def say_Apoyo():
  for i in range(3):
    time.sleep(2)
    print("Apoyo")


t1 = threading.Thread(target=say_Hi)
t2 = threading.Thread(target=say_Apoyo)
t1.start()
t2.start()

from threading import Thread

class Myclass(Thread):
  def show1(self):
    for i in range(0,20):
      print(i)

  def show2(self):
    for j in range(0,10):
      print(i)

if __name__ == "__main__" :
  t=Thread(target = show)
  t.start()
  t.join()
  t2=Thread(target=show1)
  t2.start()

import time
import threading

def thread_1(i):
    time.sleep(2)
    print('Value by Thread 1:', i)

def thread_2(i):
    time.sleep(5)
    print('Value by Thread 2:', i)

def thread_3(i):
    print('Value by Thread 3:', i)


# Creating three sample threads
thread1 = threading.Thread(target=thread_1, args=(1,))
thread2 = threading.Thread(target=thread_2, args=(2,))
thread3 = threading.Thread(target=thread_3, args=(3,))

# Running three thread object
thread1.start()
thread1.join()
thread2.start()
thread2.join()
thread3.start()
thread3.join()

print()
# Creating another 3 threads
thread4 = threading.Thread(target=thread_1, args=(1,))
thread5 = threading.Thread(target=thread_2, args=(2,))
thread6 = threading.Thread(target=thread_3, args=(3,))

thread4.start()
thread5.start()
thread6.start()
thread4.join()
thread5.join()
thread6.join()

class TV:
  def Sony(self , name , l1):
    print("first ",name)
    l1.acquire()
    for count in range(1,100):
      print(name)
      l1.release()
      print("out first0" , name)


class Person1:
  def __init__(self, tv,name,l1):
    super().__init__()
    self.tv=tv
    self.name=name
    self.l1=l1

  def run(self):
    self.tv.sony(self.name , self.l1)


class Person2:
  def __init__(self,tv,name,l1):
     super().__init__()
     self.tv=tv
     self.name=name
     self.l1=l1

  def run(self):
    self.tv.sony(self.name ,self.l1)


if __name__ == "__main__":
  tv =TV()
  l1=Lock()
  p1=Person1(tv , "gauri",l1)
  p2=Person2(tv , "gaurik",l1)
  p1.start()
  p2.start()

"""**16 JUNE 2023**"""

#unit testing

assert sum([2,3,5]) == 10 , "should be `10"

def test_sum():
  assert sum([2,3,5]) == 10 , "it should be 10"

if __name__ == "__main__":
  test_sum()
  print("everything")

def test_sum():
  assert sum([2,3,5]) == 19, "it should be 10"

if __name__ == "__main__":
  test_sum()
  print("everything")

def test_sum():
  assert sum([2,3,5]) == 10 , "it is 10"

def test_sub():
  assert min([4,2])==2,"it should be 2"

if __name__ == "__main__":
  test_sum()
  test_sub()
  print("correct")

import unittest
class TestingSum(unittest.TestCase):

  def test_sum(self):
    self.assertEqual(sum([2,3,5]) , 10 , "it shoyld be 10")

  def test_min(self):
    self.assertEqual(min([2,3]) ,2,"it should be 2")

if __name__ == "__main__":
  unittest.main()

import unittest
class TestingSum(unittest.TestCase):

    def test_sum(self):
        self.assertEqual(sum([2, 3, 5]), 10, "It should be 10")
    def test_sum_tuple(self):
        self.assertEqual(sum((1, 3, 5)), 10, "It should be 10")

if __name__ == '__main__':
    unittest.main()

pip install numpy

"""**17 june 2023**"""

import numpy as np

list1 = [1,2,3,4]
ar1 = np.array(list1)
print(type(ar1))
print(ar1)

import numpy as np  #should have same length

list1 = [1,2,3,4]
ar1 = np.array(list1)
print(type(ar1))
print(ar1)
list2=[1,2,3,4]
ar2=np.array(list2)
print(ar1 + ar2)

list3=[1,2,3]
list4=[5,6,7]

ar3 =  np.array([list3,list4])
print(ar3)
print(ar3[1][0])

arZeros = np.zeros(3,dtype=int)  #by default  float
print(arZeros)

arOnes = np.ones(5)  #by default  float
print(arOnes)

arOnes = np.ones(5 , dtype=int)  #by default  float
print(arOnes)

arEmpty = np.empty(3)
print(arEmpty)

arArange = np.arange(1,25)
print(arArange)

arReshaped = np.reshape(4,6)
print(arReshaped)

arArange = np.arange(1,11)
print(arArange.max())
print(arArange.min())
print(arArange.sum())
print(arArange.mean())

aboutMyarray = np.arange(1,11).reshape(2,5)
print(aboutMyarray.ndim)
print(aboutMyarray.size)
print(aboutMyarray.shape)

listId = [1,3,4]
checkIdArray = np.array(listId)
print(checkIdArray)
print(id(checkIdArray))
print(id(checkIdArray[0]))
print(id(checkIdArray[1]))
print(id(checkIdArray[2]))

searchArray = np.arange(20,50)
print(searchArray[0:5])
print(searchArray[searchArray>30])
print(searchArray >30)

#pandas.......

l1 = [1,2,3,4]
s1 = pd.Series(l1)
print(s1)

dict1 - {1:100 , 2:200 , 3:300}
s2 = pd.Series(dict1)
print(s2)

df1 = pd.Dataframe(l1)
print(df1)

#multi objects as Series

list1 = [1,2,3,4]
list2 = [5,6,7,8]

lisMul = [list1 , list2]


sListMul = pd.Series(lisMul)
print(sListMul)

#loc
#iloc

list1 = [1,2,3,4]
list2 = [5,6,7,8]

find = [list1,list2]
dffind = pd.DataFrame(find)
print(dffind)

"""**24 june 2023**"""

#regular expressions

import re
x='how are you'
xy=re.search("^The.*Spain$",x)
print(xy)

txt="the rain in spain"
x=re.findall("ra",txt)
print(x)

import re
txt = "java \n python \n java"
x=re.search(".+",txt)
print(x)

import re
txt = "java \n python \n java"
x=re.split("\s",txt)
print(x)

import re
txt = "java \n python \n java"
x=re.split("\s",txt,2)
print(x)

import re
txt = "java python and advancce java"
x=re.sub("\s","9",txt)
print(x)

import re
txt = "java \n python \n java"
x=re.sub("\s","gk",txt,2)
print(x)

import re

txt="my nme is Gauri"
x=re.search(r"\bG\w+",txt)
print(x.span())

import re
txt="my name is Gk"
x=re.search(r"\bG\w+",txt)
print(x.string)

import re

txt="my nme is Gauri"
x=re.search(r"\bG\w+",txt)
print(x.group())